<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lvshuqi.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":330,"display":"hide","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null,"line_number":false},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":0},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="该博客在作者读大学本科期间创建，通过Hexo搭建，部署于Github Action。博客建立之初是为了防止作者遗忘已经学过的东西，将一些可以被记录的东西写下来一定程度上会减少遗忘。">
<meta property="og:type" content="website">
<meta property="og:title" content="就这样&amp;巴">
<meta property="og:url" content="https://lvshuqi.top/page/26/index.html">
<meta property="og:site_name" content="就这样&amp;巴">
<meta property="og:description" content="该博客在作者读大学本科期间创建，通过Hexo搭建，部署于Github Action。博客建立之初是为了防止作者遗忘已经学过的东西，将一些可以被记录的东西写下来一定程度上会减少遗忘。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Shangjhih Jhao">
<meta property="article:tag" content="Hexo">
<meta property="article:tag" content="博客">
<meta property="article:tag" content="技术">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="随想">
<meta property="article:tag" content="编程">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://lvshuqi.top/page/26/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>就这样&巴</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">就这样&巴</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人网志</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lvshuqi.top/2025/09/12/Cloudflare-CDN-IP%E4%BC%98%E9%80%89%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://s2.loli.net/2025/05/17/kIwcMmTsEvbpKfe.png">
      <meta itemprop="name" content="Shangjhih Jhao">
      <meta itemprop="description" content="该博客在作者读大学本科期间创建，通过Hexo搭建，部署于Github Action。博客建立之初是为了防止作者遗忘已经学过的东西，将一些可以被记录的东西写下来一定程度上会减少遗忘。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="就这样&巴">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/12/Cloudflare-CDN-IP%E4%BC%98%E9%80%89%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">Cloudflare CDN IP优选规范</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-09-12 15:18:05 / 修改时间：16:47:36" itemprop="dateCreated datePublished" datetime="2025-09-12T15:18:05+08:00">2025-09-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cloudflare-CDN-%E4%BC%98%E9%80%89IP/" itemprop="url" rel="index"><span itemprop="name">-Cloudflare CDN -优选IP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="https://s2.loli.net/2025/09/12/TutYMHByjvCW7Le.png" alt="image.png"></p>
<h2 id="什么是Cloudfalre-CDN-摘自CF官网"><a href="#什么是Cloudfalre-CDN-摘自CF官网" class="headerlink" title="什么是Cloudfalre CDN(摘自CF官网)"></a>什么是Cloudfalre CDN(摘自CF官网)</h2><h2 id="Cloudflare-CDN"><a href="#Cloudflare-CDN" class="headerlink" title="Cloudflare CDN"></a>Cloudflare CDN</h2><p><strong>一个全球性的企业级内容分发网络（CDN）</strong></p>
<p>我们的 CDN 得到全球 330 个节点的支持，根据设备、浏览器和带宽需求优化静态和动态内容。<br><img src="https://s2.loli.net/2025/09/12/hG5dpOFWKPIRJD2.png" alt="image.png"></p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><strong>提高内容可用性和冗余性</strong><br>我们的 CDN 在 Cloudflare 每个数据中心的每台服务器上运行每项服务，确保内容从最近的可用位置交付最终用户。</p>
<p>我们全球网络的覆盖范围之广，能够以最高规模交付静态和动态内容，同时最大限度地提高性能和韧性。</p>
<p><strong>Cloudflare CDN 简介</strong></p>
<p>Cloudflare 为 CDN 提供软件即服务 (SaaS) 模式。借助 Cloudflare 的 SaaS 模式，客户无需管理或维护任何基础设施或软件即可享受 Cloudflare CDN 的便利。</p>
<p>Cloudflare CDN 的优势可归因于以下两点，本节将更详细地讨论。</p>
<ol>
<li>CDN 通过将内容缓存在靠近用户的服务器上，本质上提高了性能</li>
<li>独特的Cloudflare架构和集成生态系统</li>
</ol>
<p>图 2 展示了 Cloudflare CDN 的简化视图。客户端从 Cloudflare 全球任播网络上距离其最近的服务器接收响应，从而大幅降低了延迟和 RTT。该图描绘了无论客户端和源站的物理位置如何，都能获得一致的最终用户体验。<br><img src="https://s2.loli.net/2025/09/12/T1lOIdZk2e8NsvH.png" alt="image.png"></p>
<p>图 2：使用任播向 Cloudflare CDN 发出的 HTTP 请求</p>
<p><strong>Cloudflare CDN 架构和设计</strong></p>
<p>图 3 是 Cloudflare CDN 在全球任播网络上的视图。除了使用任播来提高网络性能和弹性之外，Cloudflare CDN 还利用分层缓存来提供优化的结果，同时为客户节省成本。客户还可以<a target="_blank" rel="noopener" href="https://developers.cloudflare.com/argo-smart-routing/get-started/">启用 Argo Smart Routing</a>来找到最快的网络路径，将请求路由到源服务器。本文档的其余部分将详细讨论这些功能。<br><img src="https://s2.loli.net/2025/09/12/9lKL6cPigw3EMIF.png" alt="image.png"><br>图 3：Cloudflare CDN 在全球任播网络上采用分层缓存</p>
<hr>
<p>在上图中，需要了解有关 Cloudflare CDN 及其所在的全球任播网络的一些重要关键点：</p>
<p>一个重要的区别是，Cloudflare 利用一个全球网络并在每个 Cloudflare 数据中心的每台服务器上运行每项服务，从而为最终用户提供与 Cloudflare 服务最接近的服务，并具有最高的规模、弹性和性能。<br>Cloudflare 是一个反向代理，这意味着它接收来自客户端的请求，并将请求代理回客户的源站。因此，每个请求在到达客户网络之前都会经过 Cloudflare 的网络。由于 Cloudflare 已在边缘（入口）强化并保护了其基础设施，因此所有客户也都受到了保护，免受基础设施级别和容量型 DDoS 攻击。请求和流量必须经过受保护的 Cloudflare 网络才能到达客户的源站。<br>Cloudflare CDN 利用 Cloudflare 全球任播网络。因此，传入的请求将被路由到距离用户最近的节点并由该节点进行响应。<br>任播的固有优势在于延迟更低、网络弹性更强、可用性更高，以及由于覆盖范围更大（可同时吸收合法流量负载和 DDoS 攻击）而增强的安全性。Cloudflare 的全球任播网络覆盖全球数百个城市↗，可在 50 毫秒内覆盖全球 95% 的互联网用户，同时提供超过 405 Tbps 的网络容量和 DDoS 防护能力。<br>Cloudflare 网络中的边缘节点缓存来自源服务器的内容，并能够通过缓存副本响应请求。Cloudflare 还使用相同的边缘架构提供DNS、DDoS 防护、WAF以及其他性能、可靠性和安全性服务。<br>Argo在 Cloudflare 网络中使用优化的路由和缓存技术，以更快、更可靠、更安全地向用户提供响应。Argo 包含智能路由和分层缓存功能。Cloudflare 利用 Argo 提供增强型 CDN 解决方案。</p>
<p><strong>分层缓存</strong></p>
<p>站点上线后，系统会默认配置标准缓存。使用标准缓存时，每个数据中心都充当源站服务器的直接反向代理。任何数据中心的缓存未命中都会导致请求从入口数据中心发送到源站服务器。</p>
<p>虽然标准缓存有效，但它并非最佳设计——靠近客户端的缓存内容可能已存在于其他 Cloudflare 数据中心，因此有时会导致源服务器不必要地过载。因此，最好启用分层缓存，该功能包含在所有 Cloudflare 套餐中。使用分层缓存，某些数据中心可以作为其他数据中心的源服务器的反向代理，从而提高缓存命中率并缩短响应时间。</p>
<p>分层缓存利用 Cloudflare 网络的规模来最大限度地减少对客户源的请求。当请求进入 Cloudflare 数据中心时，如果请求的内容未在本地缓存，则会检查其他 Cloudflare 数据中心是否存在缓存内容。</p>
<p>与数据中心和客户源服务器之间的连接相比，Cloudflare 数据中心之间的距离更短，路径更快，从而优化了对客户端的响应，并显著提高了缓存命中率。Cloudflare CDN 利用 Argo Smart Routing 数据来确定用于分层缓存的最佳上层数据中心。Argo Smart Routing 还可以作为插件启用，以便在出现缓存未命中和其他类型的动态流量时，提供数据中心和源服务器之间的最快路径。</p>
<p>Cloudflare CDN 允许客户配置分层缓存。请注意，根据 Cloudflare 套餐的不同，分层缓存的拓扑结构会有所不同。默认情况下，分层缓存处于禁用状态，您可以在主菜单的“缓存”选项卡下启用。</p>
<p><strong>多的就不讲了，感兴趣的请自行查看</strong><a target="_blank" rel="noopener" href="https://developers.cloudflare.com/reference-architecture/architectures/cdn/">内容分发网络 (CDN) 参考架构</a></p>
<h1 id="优选方式"><a href="#优选方式" class="headerlink" title="优选方式"></a>优选方式</h1><h2 id="工具优选"><a href="#工具优选" class="headerlink" title="工具优选"></a>工具优选</h2><p>在Gtihub有提供一个名为<a target="_blank" rel="noopener" href="https://github.com/XIU2/CloudflareSpeedTest">XIU2&#x2F;CloudflareSpeedTest</a>的项目，该项目可以为何用户提供多种优选姿势，无论是一键优选还是附带参数的优选，统统都有提供，具体使用方法请参考项目的<a target="_blank" rel="noopener" href="https://github.com/XIU2/CloudflareSpeedTest">README</a>文件。</p>
<p><strong>进阶使用</strong></p>
<blockquote>
<p>C:&gt;cfst.exe -h</p>
<p>CloudflareSpeedTest vX.X.X<br>测试各个 CDN 或网站所有 IP 的延迟和速度，获取最快 IP (IPv4+IPv6)！<br><a target="_blank" rel="noopener" href="https://github.com/XIU2/CloudflareSpeedTest">https://github.com/XIU2/CloudflareSpeedTest</a></p>
<p>参数：<br>    -n 200<br>        延迟测速线程；越多延迟测速越快，性能弱的设备 (如路由器) 请勿太高；(默认 200 最多 1000)<br>    -t 4<br>        延迟测速次数；单个 IP 延迟测速的次数；(默认 4 次)<br>    -dn 10<br>        下载测速数量；延迟测速并排序后，从最低延迟起下载测速的数量；(默认 10 个)<br>    -dt 10<br>        下载测速时间；单个 IP 下载测速最长时间，不能太短；(默认 10 秒)<br>    -tp 443<br>        指定测速端口；延迟测速&#x2F;下载测速时使用的端口；(默认 443 端口)<br>    -url <a target="_blank" rel="noopener" href="https://cf.xiu2.xyz/url">https://cf.xiu2.xyz/url</a><br>        指定测速地址；延迟测速(HTTPing)&#x2F;下载测速时使用的地址，默认地址不保证可用性，建议自建；<br>        当下载测速时，软件会从 HTTP 响应头中获取该 IP 当前地区码（支持 Cloudflare、AWS CloudFront、Fastly、Gcore、CDN77、Bunny 等 CDN）并显示出来。</p>
<pre><code>-httping
    切换测速模式；延迟测速模式改为 HTTP 协议，所用测试地址为 [-url] 参数；(默认 TCPing)
    当使用 HTTP 测速模式时，软件会从 HTTP 响应头中获取该 IP 当前地区码（支持 Cloudflare、AWS CloudFront、Fastly、Gcore、CDN77、Bunny 等 CDN）并显示出来。
    注意：HTTPing 本质上也算一种 网络扫描 行为，因此如果你在服务器上面运行，需要降低并发(-n)，否则可能会被一些严格的商家暂停服务。
    如果你遇到 HTTPing 首次测速可用 IP 数量正常，后续测速越来越少甚至直接为 0，但停一段时间后又恢复了的情况，那么也可能是被 运营商、Cloudflare CDN 认为你在网络扫描而 触发临时限制机制，因此才会过一会儿就恢复了，建议降低并发(-n)减少这种情况的发生。
-httping-code 200
    有效状态代码；HTTPing 延迟测速时网页返回的有效 HTTP 状态码，仅限一个；(默认 200 301 302)
-cfcolo HKG,KHH,NRT,LAX,SEA,SJC,FRA,MAD
    匹配指定地区；IATA 机场地区码或国家/城市码，英文逗号分隔，大小写均可，仅 HTTPing 模式可用；(默认 所有地区)
    支持 Cloudflare、AWS CloudFront、Fastly、Gcore、CDN77、Bunny 等 CDN
    其中 Cloudflare、AWS CloudFront、Fastly 使用的是 IATA 三字机场地区码，如：HKG,LAX
    其中 CDN77、Bunny 使用的是 二字国家/区域码，如：US,CN
    其中 Gcore 使用的是 二字城市码，如：FR,AM
    因此大家使用 -cfcolo 指定地区码时要根据不同的 CDN 来指定不同类型的地区码。

-tl 200
    平均延迟上限；只输出低于指定平均延迟的 IP，各上下限条件可搭配使用；(默认 9999 ms)
-tll 40
    平均延迟下限；只输出高于指定平均延迟的 IP；(默认 0 ms)
-tlr 0.2
    丢包几率上限；只输出低于/等于指定丢包率的 IP，范围 0.00~1.00，0 过滤掉任何丢包的 IP；(默认 1.00)
-sl 5
    下载速度下限；只输出高于指定下载速度的 IP，凑够指定数量 [-dn] 才会停止测速；(默认 0.00 MB/s)

-p 10
    显示结果数量；测速后直接显示指定数量的结果，为 0 时不显示结果直接退出；(默认 10 个)
-f ip.txt
    IP段数据文件；如路径含有空格请加上引号；支持其他 CDN IP段；(默认 ip.txt)
-ip 1.1.1.1,2.2.2.2/24,2606:4700::/32
    指定IP段数据；直接通过参数指定要测速的 IP 段数据，英文逗号分隔；(默认 空)
-o result.csv
    写入结果文件；如路径含有空格请加上引号；值为空时不写入文件 [-o &quot;&quot;]；(默认 result.csv)

-dd
    禁用下载测速；禁用后测速结果会按延迟排序 (默认按下载速度排序)；(默认 启用)
-allip
    测速全部的IP；对 IP 段中的每个 IP (仅支持 IPv4) 进行测速；(默认 每个 /24 段随机测速一个 IP)

-debug
    调试输出模式；会在一些非预期情况下输出更多日志以便判断原因；(默认 关闭)
    目前该功能仅针对 HTTPing 延迟测速过程 及 下载测速过程，当过程中因为各种原因导致当前 IP 测速中断都会输出错误原因
    例如：HTTPing 延迟测速过程中，因为 HTTP 状态码不符合或测速地址有问题或超时等原因而终止测速
    例如：下载测速过程中，因为下载测速地址有问题（被阻断、403状态码、超时）等原因而终止测速（导致显示 0.00）

-v
    打印程序版本 + 检查版本更新
-h
    打印帮助说明
</code></pre>
</blockquote>
<h2 id="网站优选"><a href="#网站优选" class="headerlink" title="网站优选"></a>网站优选</h2><p>关于网站优选，这里仅提供一个常用的地址，其它优选网站请自行搜索。</p>
<p><a target="_blank" rel="noopener" href="https://stock.hostmonit.com/CloudFlareYes">优选网站</a></p>
<p>该网站会提供各个IP<code>所属运营商</code>、<code>ip地址</code>、<code>延迟Latency</code>、<code>丢包率Loss</code>,通过这几个主要参数就可以判断出IP是否合适，因为Cloudfalre会不停的增删服务器，所以一切都有变故，如IP失效，请继续在此优选。</p>
<!--  https://api.uouin.com/cloudflare.html 这个是更全面的检测网站，仅给各位查看网站源代码的各位参考 -->





<h1 id="优选指标"><a href="#优选指标" class="headerlink" title="优选指标"></a>优选指标</h1><h2 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h2><p>延迟决定了这个CDN节点在你所在的网络环境下是否可以正常连接，在代理软件使用https与CDN进行连接的时候是有网络延迟的，这个网站所筛选出来的IP都是根据你现在网络所优选出的<strong>适合你当前网络</strong>的CDN，切换网络环境时就有可能达不到理论状态，有可能会出现网络变慢或者无法连接的情况。</p>
<p>同时，假如你的网络运营商换了，那节点的连通性和速度也会发生改变。请根据自己的网络事先选择好合适的运营商节点。</p>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>CDN节点的带宽也是衡量该CDN质量的重要指标，在流量的传输中，<strong>带宽取决于当前网络链路中外宽最低的那台设备</strong>，所以该节点的带宽就是整条链路的瓶颈。毕竟购买用于搭建节点的VPS一定是大带宽高流量的设备，任凭CDN设备跑也不会突破带宽限制。CDN带宽一般都是在1Mb到500Mb，理论上一定不会突破VPS物理带宽。</p>
<p>整条链路中，CDN既充当代理人的身份为你向外请求数据，又会将请求的数据重新发给你，所以CDN就决定了链路带宽的下限。</p>
<p><img src="https://s2.loli.net/2025/09/12/RAYqSXUdJix7WbK.png" alt="image.png"></p>
<p>关于带宽的选择，其优先级应当是次于网路延迟，只有网络能联通才能考虑带宽，所以这两个参数都是极其重要的。高带宽意味着带宽冗余，在观看流媒体的时候可以明显看出其区别。高带宽就是可以观看高清晰度的视频，而低带宽的观看高清视频会出现卡顿与延迟，正常的非大流量行为不会受到带宽影响，也不会影响到你的网络聊天与网页访问。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>手动优选IP一般应用于网络加速服务，至于实际的场景，各位有需求的想必是心知肚明。</p>
<p>请注意：该方法具有时效性也挑场景，请各位根据自己的需求结合以上内容选择真正合适自己的。</p>
<p><strong>以下是其常见的工作逻辑：</strong></p>
<p><img src="https://s2.loli.net/2025/09/12/cbSAweTWJDvCOmR.png" alt="image.png"></p>
<blockquote>
<p>这张图详细展示了CDN（内容分发网路）的工作原理。</p>
<h3 id="核心节点解析"><a href="#核心节点解析" class="headerlink" title="核心节点解析"></a>核心节点解析</h3><ol>
<li><strong>江苏用户（User）</strong>：发起请求的终端使用者。</li>
<li>**LDNS 本地DNS(Local DNS)**：使用者电脑配置的本地域名伺服器，通常由网路服务提供者(ISP)提供。它是使用者发出DNS解析请求的第一站。</li>
<li>**DNS伺服器(DNS Server)**：网站的权威DNS伺服器，负责管理<code>juejin.cn</code>这个网域的记录。</li>
<li>**CDN厂商(CDN Provider)**：CDN服务提供商的整体系统，其核心是将内容分发到各地的伺服器(边缘节点)。<br>***调度系统(Scheduling System)**：CDN的核心智慧部分。它根据使用者的地理位置、网路状况、边缘节点的负载等因素，智慧地将使用者导向最近、最快的边缘节点。<br>***管理(Management)**：负责CDN内容的更新、快取策略的配置和分发。<br>***(江苏)边缘节点((江苏)Edge Node)**：CDN在全国各地部署的伺服器。它们快取网站内容，直接响应附近使用者的请求，从而减少延迟。</li>
<li>**源站(Origin Server)**：网站内容的原始伺服器。当CDN边缘节点没有请求的内容时，会向源站回源（获取内容）。</li>
</ol>
<h3 id="运行逻辑串联（分步解析）"><a href="#运行逻辑串联（分步解析）" class="headerlink" title="运行逻辑串联（分步解析）"></a>运行逻辑串联（分步解析）</h3><p>整个过程可分为两个主要阶段：DNS解析阶段和内容请求阶段。</p>
<p><strong>阶段一：DNS解析(步骤1-7)</strong></p>
<ol>
<li><strong>使用者发起请求（步骤1）</strong>：江苏使用者在浏览器中输入<code>juejin.cn</code>，浏览器首先向本地LDNS伺服器发出对<code>juejin.cn</code>的IP地址查询请求。</li>
<li><strong>LDNS向权威DNS查询（步骤2）</strong>：本地LDNS没有<code>juejin.cn</code>的IP快取，因此向其权威DNS伺服器发出查询。</li>
<li><strong>权威DNS返回CNAME记录（步骤3）</strong>：权威DNS伺服器返回一个CNAME（别名）记录，指向CDN厂商的域名，例如<code>juejin.cn.w.cdngsb.com</code>。这一步是CDN工作的关键，它将请求的解析权转交给了CDN。</li>
<li><strong>LDNS再次查询（步骤4）</strong>：LDNS收到CNAME记录后，会继续向CDN的调度系统查询<code>juejin.cn.w.cdngsb.com</code>这个域名的IP地址。</li>
<li><strong>调度系统返回边缘节点IP（步骤5）</strong>：CDN的调度系统根据LDNS的IP地址判断出使用者来自江苏，并找到一个离使用者最近、负载最轻的江苏边缘节点，将其IP地址（<code>36.156.181.240</code>）返回给LDNS。</li>
<li><strong>LDNS快取IP（步骤6）</strong>：本地LDNS将这个IP地址快取起来，以便下次使用者再次请求时可以直接返回，加快解析速度。</li>
<li><strong>LDNS返回IP给使用者（步骤7）</strong>：LDNS将解析得到的边缘节点IP地址返回给使用者的浏览器。</li>
</ol>
<p><strong>阶段二：内容请求与分发（步骤8-11）</strong></p>
<ol start="8">
<li><strong>使用者发起内容请求（步骤8）</strong>：浏览器拿到IP地址后，直接向该IP地址（江苏边缘节点）发出对<code>juejin.cn</code>内容的请求。</li>
<li><strong>边缘节点处理请求（步骤9）</strong>：边缘节点收到请求后，会首先检查自己是否有该内容的快取。<br>***快取命中(Cache Hit)**：如果节点有快取，它会直接将快取内容返回给使用者，整个过程结束。这极大地提高了访问速度。<br>*<strong>快取未命中（Cache Miss）</strong>：如果节点没有快取，它会向源站发出请求，获取原始内容。源站返回内容给边缘节点后，边缘节点会将内容快取下来（步骤10），再返回给使用者（步骤11）。</li>
<li><strong>边缘节点快取内容（步骤10）</strong>：在快取未命中的情况下，边缘节点从源站获取内容后，会将其储存到本地，以便后续同一地区的其他使用者请求时可以直接提供服务。</li>
<li><strong>返回给使用者（步骤11）</strong>：无论是快取命中还是从源站回源后，边缘节点最终都会将网站内容返回给使用者，使用者可以在浏览器中看到网页内容。</li>
</ol>
<p>这个流程通过CDN的边缘节点，有效地将内容从远处的源站拉到靠近使用者的位置，从而大幅减少了网路延迟，提高了网站的访问速度和稳定性。</p>
</blockquote>
<h2 id="流量：分层缓存、智能分层缓存拓扑"><a href="#流量：分层缓存、智能分层缓存拓扑" class="headerlink" title="流量：分层缓存、智能分层缓存拓扑"></a>流量：分层缓存、智能分层缓存拓扑</h2><p>分层缓存已通过智能分层缓存拓扑启用。该图描绘了两个独立的流量，总结如下。第一个流量（客户端 1）是来自客户端的请求，该请求进入数据中心 1。第二个流量（客户端 2）是同一资源的后续请求，该请求进入另一个数据中心（数据中心 2）。</p>
<p><img src="https://s2.loli.net/2025/09/12/tgQpH72zEWeumSi.png" alt="image.png"></p>
<blockquote>
<h3 id="核心概念：Anycast广播"><a href="#核心概念：Anycast广播" class="headerlink" title="核心概念：Anycast广播"></a>核心概念：Anycast广播</h3><p>在上一张图中，CDN是通过<strong>DNS解析</strong>（CNAME）将使用者请求导向最近的节点IP。而这张图的核心是<strong>Anycast</strong>技术。</p>
<p>Anycast是一种网路路由技术，它允许<strong>多个伺服器</strong>广播<strong>同一个IP位址</strong>。当使用者发出请求时，网际网路的路由协定（BGP）会自动将请求路由到<strong>离使用者网路最近</strong>的、正在广播此IP的伺服器。</p>
<p>这就解释了图中两个使用者（<code>Internet User</code>）是如何向同一个IP位址（<code>Request 1</code>和<code>Request 2</code>都指向<code>DC1</code>和<code>DC3</code>的IP）发起请求，但被导向了不同的资料中心。与DNS导向相比，Anycast在网路层面实现了更快速、更直接的流量分发。</p>
<hr>
<h3 id="Cloudflare网路架构节点解析"><a href="#Cloudflare网路架构节点解析" class="headerlink" title="Cloudflare网路架构节点解析"></a>Cloudflare网路架构节点解析</h3><p>图中的 Cloudflare 网路分为两个主要层级：</p>
<ol>
<li><p><strong>Lower Tier(下层)资料中心</strong>：<br> *如图中的<code>DC1</code>和<code>DC3</code>，这些是<strong>边缘资料中心</strong>，数量最多，遍布全球。它们是使用者请求的<strong>第一站</strong>。<br>  *这些节点部署了多种服务，用于即时处理和过滤流量：<br> <strong>DNS</strong>：处理域名解析请求。<br>  *<strong>DDoS</strong>：即时缓解分散式阻断服务攻击。<br>  *<strong>WAF（Web Application Firewall）</strong>：保护网站免受常见的应用层攻击（如SQL注入、跨站脚本等）。<br>  *<strong>Bot Management</strong>：区分并管理来自合法或恶意机器人的流量。<br>  <strong>API Gateway</strong>：管理和保护API流量。<br>  *<strong>Cache&#x2F;CDN</strong>：快取静态内容，直接响应使用者请求。</p>
</li>
<li><p><strong>Upper Tier(上层)资料中心</strong>：<br> *如图中的<code>DC6</code>，这些是规模更大、更集中的<strong>核心资料中心</strong>。它们充当下层资料中心和**源站(Origin)**之间的桥梁。<br>  *当下层资料中心没有快取内容时，请求会被导向这里。这些上层节点通常有更丰富的快取内容，并且与源站的网路连接更优越。</p>
</li>
</ol>
<hr>
<h3 id="请求与响应的运行逻辑"><a href="#请求与响应的运行逻辑" class="headerlink" title="请求与响应的运行逻辑"></a>请求与响应的运行逻辑</h3><p>整个流程可以分为两个路径：一个是快取命中，一个是快取未命中（回源）。</p>
<ol>
<li><strong>使用者发起请求</strong>：</li>
</ol>
<ul>
<li><code>Internet User</code>向Cloudflare广播的IP位址发出请求。<br>*基于Anycast路由，请求被导向网路层面上<strong>最近</strong>的<code>Lower Tier</code>资料中心（例如，一个使用者被导向<code>DC1</code>，另一个被导向<code>DC3</code>）。</li>
</ul>
<ol start="2">
<li><p><strong>下层资料中心处理</strong>：<br> *<code>Lower Tier</code>资料中心收到请求后，首先会通过<strong>DDoS</strong>、<strong>WAF</strong>和<strong>Bot Management</strong>等服务对请求进行安全审核和过滤。<br>  *如果请求的内容在本地<strong>Cache&#x2F;CDN</strong>中，则直接返回响应，此时整个过程结束。这就是最快的情况。</p>
</li>
<li><p><strong>请求转发到上层（快取未命中）</strong>：<br> *如果下层资料中心没有快取内容，它会将请求<strong>转发</strong>到<code>Upper Tier</code>资料中心(<code>DC6</code>)。<br>  *<code>DC6</code>检查其更庞大的快取。如果快取命中，它将直接返回响应给下层资料中心。</p>
</li>
<li><p><strong>Back Source to Original Server</strong>: a.<br> *如果上层资料中心也没有快取内容，它会发出最终请求，<strong>回源</strong>到<strong>Origin</strong>（原始伺服器）以获取内容。</p>
</li>
<li><p><strong>响应返回</strong>：</p>
</li>
</ol>
<ul>
<li><code>Origin</code>将响应传回给<code>Upper Tier</code>资料中心(<code>DC6</code>)。<br>*<code>DC6</code>会<strong>快取</strong>此响应，然后传给<code>Lower Tier</code>资料中心(<code>DC1</code>或<code>DC3</code>)。<br>*<code>Lower Tier</code>资料中心也会<strong>快取</strong>此响应，并最终将其传回给<code>Internet User</code>。</li>
</ul>
<p>这种多层级、Anycast驱动的架构，让Cloudflare不仅能高效分发内容（CDN），还能在距离使用者最近的网路边缘对流量进行多重安全过滤，提供了更强大的性能和防护能力。</p>
</blockquote>
<h2 id="区域分层缓存"><a href="#区域分层缓存" class="headerlink" title="区域分层缓存"></a>区域分层缓存</h2><p>智能分层缓存和全局分层缓存的主要区别在于可以与源服务器通信的上层缓存数量。智能分层缓存会使用 Argo 性能和路由数据选择距离源服务器最近的上层缓存。这意味着所有<code>MISS</code>在下层缓存中遇到的请求都将流经该上层缓存，从而有更高的几率到达缓存<code>HIT</code>，避免将流量发送到源服务器。然而，这种架构的缺点是下层缓存可能位于与上层缓存相距甚远的地方。即使上层缓存能够处理请求，上下层缓存之间的距离仍然可能增加响应延迟，具体取决于传输距离。总而言之，智能分层缓存确保所有缓存请求都流经单个上层缓存位置，从而提高缓存<code>HIT</code>利用率，并减少对源服务器的请求，但是，由于上层缓存可能与发出请求的下层缓存相距甚远，因此处理这些请求的延迟可能会更高。</p>
<p>借助通用全局分层缓存，Cloudflare 使用其全球最大的数据中心作为上层缓存，这意味着，通常情况下，上层缓存与下层缓存的距离更近。当下层缓存需要将请求传递到上层时，这可以显著降低延迟。然而，这最终会增加源服务器处理的请求量，因为每个上层缓存都需要从源服务器进行填充。总而言之，通用全局分层缓存可以在缓存填充后缩短响应时间，但也会增加源服务器的负载。</p>
<p>区域分层缓存通过在架构中添加额外的缓存层，将这两种策略的优势完美结合。将区域分层缓存选项与智能分层缓存结合使用意味着，虽然存在一个距离源站最近的上层缓存位置，但在上层和下层之间添加了一个地理位置更靠近下层的区域层。现在，来自下层的请求在发送到上层之前会先检查区域层是否存在缓存。单个区域层可以接受来自多个下层缓存的请求，因此可以显著改善全局可用应用程序的性能和延迟。</p>
<p>建议将区域分层缓存与智能分层缓存和自定义分层缓存配合使用。但是，对于在多个区域拥有多个上层缓存的客户（例如通用全局分层缓存），区域分层缓存并不适用。</p>
<h3 id="流量：分层缓存、智能分层缓存与区域分层缓存"><a href="#流量：分层缓存、智能分层缓存与区域分层缓存" class="headerlink" title="流量：分层缓存、智能分层缓存与区域分层缓存"></a>流量：分层缓存、智能分层缓存与区域分层缓存</h3><p>在图 5 中，分层缓存已启用智能分层缓存拓扑。该图描绘了启用区域分层缓存的智能分层缓存拓扑。较低层级的缓存在遇到缓存时，<code>MISS</code>会首先将请求发送到更本地的区域中心数据中心，以查看该缓存是否可以处理该请求。如果无法处理，则请求将继续发送到上层，然后根据需要发送到源服务器。</p>
<p><img src="https://s2.loli.net/2025/09/12/Oc8FbptWuGElsSR.png" alt="image.png"></p>
<blockquote>
<p>这张图是<strong>Cloudflare Anycast 网路</strong>的进阶架构，相比全局区域缓存，它增加了一个新的层级：**区域层 (Regional Tier)**。这使得整个网路结构更加分层和高效。</p>
<hr>
<h3 id="三层级架构解析"><a href="#三层级架构解析" class="headerlink" title="三层级架构解析"></a>三层级架构解析</h3><ol>
<li><strong>Lower Tier（下层）资料中心</strong>：</li>
</ol>
<ul>
<li>这是<strong>最边缘的节点</strong>，数量最多，也是使用者请求的第一站。 </li>
<li>它们主要负责<strong>前端流量处理</strong>，包括DDoS缓解、WAF保护、Bot管理，并提供最基础的快取（<strong>Cache &#x2F; CDN</strong>）。其核心职责是在离使用者最近的地方处理请求，以达到最低延迟。</li>
</ul>
<ol start="2">
<li><strong>Regional Tier（区域层）资料中心</strong>：</li>
</ol>
<ul>
<li>这是新加入的层级，位于下层和上层之间。 </li>
<li>它们通常是<strong>区域性的网路中心</strong>，承担着该区域内所有下层节点的回源请求。 </li>
<li>区域层的快取容量和处理能力通常比下层节点<strong>更大更强</strong>。它减少了下层节点直接回源到更远的上层节点或源站的频率，极大地提高了区域内的快取命中率和性能。</li>
</ul>
<ol start="3">
<li><strong>Upper Tier（上层）资料中心</strong>：</li>
</ol>
<ul>
<li>这是<strong>网路的核心</strong>，负责处理最终未命中的请求。 </li>
<li>它们直接连接<strong>源站 (Origin)<strong>，拥有</strong>最大的快取容量</strong>和最稳定的网路连接。当区域层都没有请求内容时，请求才会到达这里，并最终回源。</li>
</ul>
<hr>
<h3 id="请求与响应的运行逻辑（三层级版）"><a href="#请求与响应的运行逻辑（三层级版）" class="headerlink" title="请求与响应的运行逻辑（三层级版）"></a>请求与响应的运行逻辑（三层级版）</h3><p>这个新架构的运行流程更精确，旨在减少不必要的长距离回源。</p>
<ol>
<li>**请求发起 (Request)**：</li>
</ol>
<ul>
<li>使用者发起请求，Anycast 技术将其路由到<strong>地理位置最近</strong>的 <code>Lower Tier</code> 资料中心 (DC1、DC2 或 DC3)。</li>
</ul>
<ol start="2">
<li><strong>下层节点快取查询</strong>：</li>
</ol>
<ul>
<li>下层节点接收请求后，首先检查本地快取。如果<strong>命中</strong>，直接返回响应。</li>
</ul>
<ol start="3">
<li><strong>请求转发至区域层</strong>：</li>
</ol>
<ul>
<li>如果下层节点<strong>未命中快取</strong>，请求会被转发到<strong>所属区域</strong>的 <code>Regional Tier</code> 资料中心 (DC4 或 DC5)。</li>
</ul>
<ol start="4">
<li><strong>区域层快取查询</strong>：</li>
</ol>
<ul>
<li>区域层节点检查其快取。如果<strong>命中</strong>，则从这里返回响应给下层节点。这就是三层架构的核心优势，它在边缘节点和核心节点之间增加了一层快取，截留了大量请求，避免了流量涌向上层。</li>
</ul>
<ol start="5">
<li><strong>请求转发至上层</strong>：</li>
</ol>
<ul>
<li>如果区域层节点<strong>也未命中快取</strong>，请求会被转发到 <code>Upper Tier</code> 资料中心 (DC6)。</li>
</ul>
<ol start="6">
<li><strong>最终回源</strong>：</li>
</ol>
<ul>
<li>上层节点检查快取。如果仍未命中，它会<strong>最终回源</strong>至 <code>Origin</code> 原始伺服器。</li>
</ul>
<ol start="7">
<li><strong>响应返回与快取</strong>：</li>
</ol>
<ul>
<li>来自 <code>Origin</code> 的响应会沿着相反的路由返回：先到 <code>Upper Tier</code>，然后到 <code>Regional Tier</code>，最后到 <code>Lower Tier</code>。在<strong>每一层</strong>，内容都会被<strong>快取</strong>起来，以备将来的请求使用。</li>
</ul>
<p>这种三层级架构确保了大多数请求在离使用者最近的边缘或区域层就能得到满足，仅在必要时才触及最远的核心层和源站，从而显著提升了性能、可靠性和安全性。</p>
</blockquote>
<h2 id="流量：缓存预留拓扑"><a href="#流量：缓存预留拓扑" class="headerlink" title="流量：缓存预留拓扑"></a>流量：缓存预留拓扑</h2><p>缓存预留如何帮助减少原始服务器上的负载，同时帮助重新填充上层和下层数据中心的缓存存储。</p>
<p><img src="https://s2.loli.net/2025/09/12/uG3XvO8T1hCAqEi.png" alt="image.png"></p>
<blockquote>
<p>這張圖是在先前 Cloudflare 三層級架構基礎上的進一步優化，主要增加了一個新的關鍵節點：<strong>Cache Reserve</strong>。</p>
<hr>
<h3 id="新增節點：Cache-Reserve"><a href="#新增節點：Cache-Reserve" class="headerlink" title="新增節點：Cache Reserve"></a>新增節點：Cache Reserve</h3><p><strong>Cache Reserve</strong> 是一個位於<strong>上層資料中心</strong>和<strong>源站 (Origin)</strong> 之間的<strong>持久化快取層</strong>。</p>
<p>與傳統的快取（位於下層、區域層、上層）不同，傳統快取通常是<strong>暫時性</strong>的，它會根據內容的熱門程度和快取時間過期策略來清除不常訪問的內容。</p>
<p>而 <strong>Cache Reserve</strong> 則是一種<strong>永久性</strong>的儲存層。它的作用就像一個完整的內容備份倉庫。即使某些內容非常冷門，在所有邊緣快取中都已過期被清除，它仍會被保留在 Cache Reserve 中。</p>
<p>這個節點的優勢非常明顯：</p>
<ul>
<li><strong>減少回源壓力</strong>：它大幅減少了對源站的回源請求，特別是針對那些不常訪問但仍需被快取保護的內容。</li>
<li><strong>提高可靠性</strong>：即使源站不可用，大部分內容仍可以從 Cache Reserve 中快速檢索並提供給使用者。</li>
<li><strong>降低成本</strong>：它減少了源站的頻寬和計算成本。</li>
</ul>
<hr>
<h3 id="運行邏輯（四層級版）"><a href="#運行邏輯（四層級版）" class="headerlink" title="運行邏輯（四層級版）"></a>運行邏輯（四層級版）</h3><p>這個新架構將回源路徑劃分為四個層級的快取檢查，最終目標是盡可能地不觸及源站。</p>
<ol>
<li><strong>邊緣層快取查詢</strong>：<ul>
<li>請求到達最近的 <strong>Lower Tier</strong> 節點。如果內容命中快取，直接返回。</li>
</ul>
</li>
<li><strong>區域層快取查詢</strong>：<ul>
<li>如果下層未命中，請求轉發到 <strong>Regional Tier</strong> 節點。如果快取命中，從這裡返回。</li>
</ul>
</li>
<li><strong>核心層快取查詢</strong>：<ul>
<li>如果區域層也未命中，請求轉發到 <strong>Upper Tier</strong> 節點。如果快取命中，從這裡返回。</li>
</ul>
</li>
<li><strong>Cache Reserve 查詢</strong>：<ul>
<li>如果所有上游快取（上層、區域層、下層）都未命中，<strong>在向源站發出請求前</strong>，會先檢查 <strong>Cache Reserve</strong>。如果內容在這裡命中，則直接返回，避免了與源站的通訊。</li>
</ul>
</li>
<li><strong>最終回源</strong>：<ul>
<li><strong>只有當</strong> Cache Reserve 仍未命中時，才會發出最終的請求，從 <strong>Origin</strong> 原始伺服器獲取內容。</li>
</ul>
</li>
</ol>
<p>整個響應返回路徑依然是相反的：<code>Origin</code> -&gt; <code>Cache Reserve</code> -&gt; <code>Upper Tier</code> -&gt; <code>Regional Tier</code> -&gt; <code>Lower Tier</code> -&gt; <code>User</code>。每經過一個節點，內容都會被快取，以備將來使用。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/25/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><span class="page-number current">26</span><a class="page-number" href="/page/27/">27</a><span class="space">&hellip;</span><a class="page-number" href="/page/82/">82</a><a class="extend next" rel="next" href="/page/27/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shangjhih Jhao"
      src="https://s2.loli.net/2025/05/17/kIwcMmTsEvbpKfe.png">
  <p class="site-author-name" itemprop="name">Shangjhih Jhao</p>
  <div class="site-description" itemprop="description">该博客在作者读大学本科期间创建，通过Hexo搭建，部署于Github Action。博客建立之初是为了防止作者遗忘已经学过的东西，将一些可以被记录的东西写下来一定程度上会减少遗忘。</div>
</div>


<div class="spotify-player-independent motion-element">
  <div class="spotify-player-header">
    <i class="fab fa-spotify"></i>
    <span>音乐推荐</span>
  </div>
  <div class="spotify-player-content">
    <iframe style="border-radius:8px" 
            src="https://open.spotify.com/embed/track/1TUpKepASZ9fQbcG2v9kOy?utm_source=generator" 
            width="100%" 
            height="152" 
            frameBorder="0" 
            allowfullscreen="" 
            allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" 
            loading="lazy">
    </iframe>
  </div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">90</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shangjhih Jhao</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">347k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:38</span>
</div>
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("09/29/2024 11:04:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已建立 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
